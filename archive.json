{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2024-08-20T01:14:59.237503+00:00",
  "repo": "bwesterb/draft-mpic",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    }
  ],
  "issues": [
    {
      "number": 1,
      "id": "I_kwDOMYks0s6TACJZ",
      "title": "Move to organisation",
      "url": "https://github.com/bwesterb/draft-mpic/issues/1",
      "state": "OPEN",
      "author": "bwesterb",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Shall we move this repo to an organisation?",
      "createdAt": "2024-08-14T16:09:14Z",
      "updatedAt": "2024-08-17T01:14:58Z",
      "closedAt": null,
      "comments": [
        {
          "author": "sciros",
          "authorAssociation": "COLLABORATOR",
          "body": "I would say we probably should, but I don't have any recommendations myself apart from a community-oriented org like open-mpic or something major like pkic.",
          "createdAt": "2024-08-17T01:14:57Z",
          "updatedAt": "2024-08-17T01:14:57Z"
        }
      ]
    },
    {
      "number": 2,
      "id": "I_kwDOMYks0s6TAY_-",
      "title": "Add CA authentication mechanism for the API endpoints",
      "url": "https://github.com/bwesterb/draft-mpic/issues/2",
      "state": "OPEN",
      "author": "bwesterb",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Probably best to make optional and suggest `Authorization` header for token.",
      "createdAt": "2024-08-14T17:00:26Z",
      "updatedAt": "2024-08-19T19:42:15Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 3,
      "id": "I_kwDOMYks0s6TAZp3",
      "title": "Make quorum deterministic?",
      "url": "https://github.com/bwesterb/draft-mpic/issues/3",
      "state": "OPEN",
      "author": "bwesterb",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "We do not want retries to help the attacker.",
      "createdAt": "2024-08-14T17:01:58Z",
      "updatedAt": "2024-08-17T01:18:43Z",
      "closedAt": null,
      "comments": [
        {
          "author": "sciros",
          "authorAssociation": "COLLABORATOR",
          "body": "There's a retry logic proposal I have written up on the open-mpic-specification here: https://github.com/open-mpic/open-mpic-specification/issues/3\r\nAgreed that some level of determinism is good so that retries _can_ (to a degree) be useful for the issuer but not for an adversary.",
          "createdAt": "2024-08-17T01:18:43Z",
          "updatedAt": "2024-08-17T01:18:43Z"
        }
      ]
    },
    {
      "number": 4,
      "id": "I_kwDOMYks0s6TAZ7h",
      "title": "Cyclic dependency in trust",
      "url": "https://github.com/bwesterb/draft-mpic/issues/4",
      "state": "OPEN",
      "author": "bwesterb",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Should the CA trust the WebPKI to authenticate the MPIC service?",
      "createdAt": "2024-08-14T17:02:41Z",
      "updatedAt": "2024-08-14T17:02:41Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 5,
      "id": "I_kwDOMYks0s6TAaNj",
      "title": "Validations methods besides http, dns, and caa",
      "url": "https://github.com/bwesterb/draft-mpic/issues/5",
      "state": "OPEN",
      "author": "bwesterb",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Do we want to add alpn?",
      "createdAt": "2024-08-14T17:03:27Z",
      "updatedAt": "2024-08-19T20:45:33Z",
      "closedAt": null,
      "comments": [
        {
          "author": "sciros",
          "authorAssociation": "COLLABORATOR",
          "body": "Right now the open-mpic API is specified to support http, dns, alpn, and caa.\r\nIs there a reason to hold off on supporting that with v1? If not then we can forge ahead with it.",
          "createdAt": "2024-08-17T02:42:25Z",
          "updatedAt": "2024-08-17T02:42:25Z"
        },
        {
          "author": "bwesterb",
          "authorAssociation": "OWNER",
          "body": "alpn is more difficult to implement, and it's rarely used. We could leave it out (for now), make it optional to implement (for now), or insist on it.",
          "createdAt": "2024-08-19T09:27:33Z",
          "updatedAt": "2024-08-19T09:27:33Z"
        },
        {
          "author": "SulemanAhmadd",
          "authorAssociation": "COLLABORATOR",
          "body": "I would vote for limiting the scope for the first draft. ALPN can be a future extension.",
          "createdAt": "2024-08-19T19:47:47Z",
          "updatedAt": "2024-08-19T19:47:47Z"
        },
        {
          "author": "sciros",
          "authorAssociation": "COLLABORATOR",
          "body": "That works for me. It's possible that real-world implementations will end up functionally ahead of the IETF draft given the current requirement timelines, so we would then just maintain a tagged reference implementation that conforms precisely to the draft spec (no ALPN).",
          "createdAt": "2024-08-19T20:45:31Z",
          "updatedAt": "2024-08-19T20:45:31Z"
        }
      ]
    },
    {
      "number": 6,
      "id": "I_kwDOMYks0s6TAaYE",
      "title": "Sign responses",
      "url": "https://github.com/bwesterb/draft-mpic/issues/6",
      "state": "OPEN",
      "author": "bwesterb",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Do we want the MPIC service to sign its responses as evidence.",
      "createdAt": "2024-08-14T17:03:51Z",
      "updatedAt": "2024-08-17T03:01:34Z",
      "closedAt": null,
      "comments": [
        {
          "author": "sciros",
          "authorAssociation": "COLLABORATOR",
          "body": "Depends on the anticipated client-service relationship(s) it'll support. At the moment I believe the open-mpic spec and implementation effectively assumes that it's to be deployed and maintained by the same organization that is acting as the client (i.e. a CA is using it for its own MPIC), then its effectively a service within that org and signing the responses doesn't add much in the way of trust (I think), especially if there are service logs available and accessible by the organization.\r\n\r\nIf we want the API to be crafted to support a client-service relationship where the API is basically externally facing (and I suppose that's the most practical reason to have a \"standard\" API at all, for there to be multiple externally available MPIC APIs hosted by, e.g., Cloudflare, etc.) then I think it's a valid question as to whether traceability and non-repudiation have a place in this. Perhaps there can be a kind of \"mode\" (configuration) under which the API is expected to be deployed -- externally facing, in which case a whole set of additional specification applies, or internally facing, in which case things are slightly simpler. Just thinking out loud.",
          "createdAt": "2024-08-17T03:01:32Z",
          "updatedAt": "2024-08-17T03:01:32Z"
        }
      ]
    },
    {
      "number": 7,
      "id": "I_kwDOMYks0s6TAbNg",
      "title": "How much levers to give the CA in the strictness of validation",
      "url": "https://github.com/bwesterb/draft-mpic/issues/7",
      "state": "OPEN",
      "author": "bwesterb",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Should we allow the client to specify the details of the quorum? Eg. min 2 out of 10. Or just a policy? Eg. CA/B 2026. Or leave it completely to the service.",
      "createdAt": "2024-08-14T17:05:28Z",
      "updatedAt": "2024-08-17T03:23:19Z",
      "closedAt": null,
      "comments": [
        {
          "author": "sciros",
          "authorAssociation": "COLLABORATOR",
          "body": "We were just having this conversation earlier today about how \"requirements-aware\" the API should be and to what extent it should enforce them.\r\nThe policy to specify is a really interesting idea.\r\nAs of this moment, the open-mpic API allows for specification of any value for the quorum, with the value of 0 effectively rendering it a logging-only service that interprets all outcomes as passing. I am thinking of proposing a change to that, and have a pull request that's under review which nudges validation logic more towards the requirements-aware side of things.\r\nAt the same time, the quorum count is currently an optional parameter. In its absence, the default can either be fully configurable by whoever owns the services (i.e. set it to something like 5 in a config file) or it can be programmatically derived based on the count of remote perspectives being interrogated (i.e. `perspective_count - 1` or `perspective_count - 2` depending on whether that count is <6 or not.)\r\n\r\nAnyway in the interest of making fast progress on this, here's my current thinking and what I'm considering implementing in the coming days, though I'm 100% OK with changing completely if my reasoning is faulty. \r\n\r\nI propose that quorum count remain an optional parameter to specify to the service, to allow for a higher-than-minimum-allowed-by-the-requirements threshold. If you want a quorum of 100%, that should be possible.\r\n\r\nI also propose that the default quorum is requirements-aware (programmatically derived). The logic used for deriving it can be policy-specific... that's something I hadn't thought of. I don't have a strong opinion on whether that should be how the service applies logic (i.e., it can apply a _non-current policy_) or whether it should just always be updated to reflect the current policy, and versioned accordingly. Perhaps the latter?\r\n\r\nI also propose that the quorum count in the API request (assuming it's a whole number) is allowed to be below the required minimum only if the API is run in a diagnostics/dev mode with value validation (as opposed to request structure validation) disabled. That, or include a warning in the response that the quorum count used is below the required threshold and therefore cannot actually be used to support cert issuance. Not sure if the latter is really a useful use case to support, though.",
          "createdAt": "2024-08-17T03:23:18Z",
          "updatedAt": "2024-08-17T03:23:18Z"
        }
      ]
    },
    {
      "number": 8,
      "id": "I_kwDOMYks0s6TYF9O",
      "title": "Endpoint naming",
      "url": "https://github.com/bwesterb/draft-mpic/issues/8",
      "state": "OPEN",
      "author": "sciros",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This question has come up as part of open-mpic as well but we may as well discuss it all here to keep things synced up.\r\n\r\nWhat should the endpoints be for the various validations/checks that we'll want performed? Due to the nature of the industry terms, there's no obviously elegant approach.\r\n\r\nI figured an easy way to start the conversation would be to throw some ideas out there to beat up on. Gemini and ChatGPT were happy to oblige, though each gave me quite different results for my question about this. Here was my prompt:\r\n\r\n> Let's talk about PKI and certificate issuance. I want to brainstorm endpoint naming for an API that would do multi-perspective issuance corroboration for various validation checks.\r\nThere are several kinds of \"verifications\" or \"validations\" that get run as part of issuing a signed certificate. Correct me where I'm wrong, because I want to be very technically pedantic about this, but I think of the checks as being, roughly, DCV (domain control validation) and then CAA (certificate authority authorization) checking. With DCV the word \"validation\" is already in the name, and with CAA it's not, so I think many people in the PKI space do refer to CAA record validation as a \"CAA check,\" and I've seen the occasional article where, perhaps for the sake of parallel terminology, people will talk of a \"DCV check.\" But if I wanted to have an API with endpoints that carry out these various verifications, what is a good way to organize and name them? Perhaps DCV should be broken out into the various validation methods? And then CAA is just alongside those as \"yet another record type\" to check the presence of? Or maybe it's \"/dcv-check\" and \"/caa-check\" and then specifying in the request body what kind of DCV validation type to carry out (HTTP, etc.)? Please ruminate on this for me.\r\n\r\nGemini gave me the following options:\r\n\r\n> **Option 1:** Hierarchical Structure; clear separation of concerns, detailed endpoint names.\r\n> `/validations/dcv`\r\n> `/validations/dcv/http`\r\n> `/validations/dcv/dns`\r\n> `/validations/dcv/email`\r\n> ...\r\n> `/validations/caa`\r\n> `/validations/ocsp` (or other validation types)\r\n> \r\n> **Option 2:** Flat Structure with Query Parameters; simplicity, flexibility.\r\n> `/validate` (or `/verify`)\r\n> Query parameters:\r\n> `type`: `dcv`, `caa`, `ocsp`, etc.\r\n> `method`: `http`, `dns`, `email`, etc. (for DCV)\r\n> \r\n> **Option 3:** Combined Approach; balance between hierarchy and simplicity.\r\n> `/dcv`\r\n> `/dcv/http`\r\n> `/dcv/dns`\r\n> `/dcv/email`\r\n> `/caa`\r\n> `/ocsp` (or other validation types)\r\n> `/validate` for generic validation requests with query parameters \r\n\r\nPersonally I wasn't fond of any of these, although if I had to choose between the above I'd go with some version of option 1 or option 3.\r\n\r\nChatGPT 4o gave me a very different answer, seemingly being led by my prompt a bit more, so I found myself biased towards it.\r\n\r\n> 1. Endpoint Structure Overview\r\n>   **DCV** (Domain Control Validation): Since DCV involves different methods (HTTP, DNS, email, etc.), it makes sense to either have \r\n> separate endpoints for each method or a single endpoint with the method specified in the request.\r\n>   **CAA** (Certificate Authority Authorization): CAA is more straightforward, typically involving a single check to see if the domain has specific CAA records that allow the issuance of a certificate by a CA.\r\n> 2. Naming Conventions\r\n> Consistency is key. If you choose to use the term \"check\" for CAA, it might be beneficial to apply it uniformly, even to DCV, despite \"validation\" already being in the name.\r\n> 3. Potential Endpoint Structures\r\n>     1. **Option A**: Separate Endpoints for Each DCV Method\r\n>     `/dcv/http-check`: Validates domain control via HTTP.\r\n>     `/dcv/dns-check`: Validates domain control via DNS.\r\n>     `/dcv/email-check`: Validates domain control via email.\r\n>     `/caa-check`: Checks the CAA records for the domain.\r\n>     Pros: Clear separation of concerns, Easy to manage and extend if new DCV methods are added.\r\n>     Cons: Potentially more endpoints to maintain.\r\n>    \r\n>     2. **Option B**: Unified DCV Endpoint with Method in Request\r\n>     `/dcv-check`: Single endpoint for DCV validation. The method (HTTP, DNS, email) is specified in the request body or as a query parameter.\r\n>     `/caa-check`: Same as in Option A.\r\n>     Pros: Fewer endpoints, which might simplify API documentation, Easier to handle common validation logic.\r\n>     Cons: Slightly more complex request handling. Less explicit endpoint naming.\r\n\r\nI'm personally partial to ChatGPT's **Option B** (and using a request body parameter for the method), as that's the direction I've proposed taking the open-mpic reference implementation for now and it's very close to its current state (v1.0.1 has `/validation` and `/caa-check` paths). But I don't know if it's the best direction to take and figure this is one of the first things we should sort out anyway for a standard API.",
      "createdAt": "2024-08-19T06:32:54Z",
      "updatedAt": "2024-08-19T21:29:31Z",
      "closedAt": null,
      "comments": [
        {
          "author": "bwesterb",
          "authorAssociation": "OWNER",
          "body": "Let me add another dimension to this discussion.\r\n\r\nInspired by certificate transparency, I proposed using `/mpic/v1` (or for the draft version now `/mpic/draft00`.)\r\n\r\n- Putting `/mpic` in the prefix allows multiple services to be run under the same URL.\r\n- Putting the version in the prefix (as compared to the request) makes it easier to run two different implementations for two different versions.\r\n\r\nIn certificate transparency, all actions have a separate endpoint (`add-chain`, `add-pre-chain`, `get-entries`, `get-sth`, etc). This makes it easier to cache or rate-limit certain endpoints.\r\n\r\nI don't see a similar advantage of putting the method in the URL in case of MPIC.",
          "createdAt": "2024-08-19T09:23:06Z",
          "updatedAt": "2024-08-19T09:23:06Z"
        },
        {
          "author": "sciros",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks Bas, that's a good point. I think specifying `/mpic/{version}` (or draft) as the base URL is good.\r\nI also agree that putting the version in the URL is sensible if you want to enable/encourage running multiple versions of the API. Especially if you are envisioning a CT log kind of situation -- many CAs posting to a few MPIC enablers -- this makes a lot of sense. If the open source, roll-your-own-mpic implementation manages to find adoption, it may be a different dynamic, but that's far from a sure thing and this kind of flexibility in the API is valuable.\r\n\r\nThat still leaves the question of the method endpoints. I agree that `dcv-html`, `dcv-dns`, etc. being separate endpoints is not particularly useful the way it can be for CT. So it's more about what makes for a more elegant and usable spec. I personally do think that there should be _some_ request path organization of what to corroborate, so it's not just \"do mpic\" and then the requested corroboration(s) is buried in the request body. To me that would feel clunky and unconventional.\r\n\r\nHow do we feel about, for example:\r\n`/mpic/v1/caa-check` (and specifying CAA specific parameters in the body)\r\n`/mpic/v1/dcv-check` (and specifying the DCV method and other relevant parameters in the body)\r\n`/mpic/v1/dcv-with-caa-check`\r\n\r\nOr is there a preference instead for paths like like `/mpic/v1/caa` and `/mpic/v1/dcv/{method}`?",
          "createdAt": "2024-08-19T21:29:31Z",
          "updatedAt": "2024-08-19T21:29:31Z"
        }
      ]
    }
  ],
  "pulls": []
}